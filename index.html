<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>疊空心磚 Hollow Stack</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#efefef; font-family: system-ui,"Noto Sans TC",Arial,sans-serif;}
  #ui{position:fixed;inset:0 0 auto 0;display:flex;justify-content:space-between;align-items:center;padding:10px 14px;pointer-events:none;}
  .pill{background:rgba(0,0,0,.65);color:#fff;padding:6px 10px;border-radius:999px;font-weight:700;letter-spacing:.5px;box-shadow:0 2px 6px rgba(0,0,0,.2);}
  #centerMsg{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;text-align:center;pointer-events:none;}
  #centerMsg .card{pointer-events:auto;background:rgba(255,255,255,.92);border-radius:16px;padding:16px 18px;box-shadow:0 8px 24px rgba(0,0,0,.25);min-width:min(90vw,460px);}
  #centerMsg h1{margin:0 0 6px;font-size:20px;}
  #centerMsg p{margin:6px 0 12px;color:#333;}
  #centerMsg .row{display:flex;gap:8px;flex-wrap:wrap;}
  button{border-radius:10px;border:none;outline:none;padding:10px 12px;font-size:16px;box-shadow:0 2px 6px rgba(0,0,0,.15);background:#111;color:#fff;cursor:pointer;}
  button.secondary{background:#e0e0e0;color:#111;}
  #canvasWrap{position:relative;width:100vw;height:100vh;}
  canvas{display:block;width:100%;height:100%;}
  .flash{animation:flash .3s linear infinite;}
  @keyframes flash{0%{opacity:1}50%{opacity:.25}100%{opacity:1}}
  #error{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:#ffeded;color:#a40000;border:1px solid #ffa8a8;border-radius:10px;padding:8px 12px;font-size:14px;display:none;}
</style>
</head>
<body>
<div id="canvasWrap"><canvas id="game"></canvas></div>

<div id="ui">
  <div id="score" class="pill">Score 0</div>
  <div id="timer" class="pill">Time 15.0</div>
</div>

<div id="centerMsg">
  <div class="card">
    <h1>疊空心磚 Hollow Stack</h1>
    <p>15 秒內，把上方左右移動的空心磚放下並堆高。疊歪會倒、掉出畫面就結束。<br/>手機：點一下　電腦：滑鼠點擊／空白鍵</p>
    <div class="row">
      <button id="startBtn">開始遊戲</button>
      <button id="howBtn" class="secondary">操作說明</button>
    </div>
  </div>
</div>

<div id="error"></div>

<!-- Matter.js（CDN） -->
<script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js" onerror="
  document.getElementById('error').style.display='block';
  document.getElementById('error').textContent='⚠️ 載入失敗：無法載入 Matter.js（可能網路或被擋）。請改用本地檔案方式，見下方說明。';
"></script>

<script>
(function(){
  // 如果 CDN 失敗，直接終止並顯示提示
  if (!window.Matter) { return; }

  const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

  const canvas = document.getElementById('game');
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  let W = window.innerWidth, H = window.innerHeight;

  // 固定單一 PNG（兩孔正面視角）
  const brickImg = new Image();
  let brickReady = false, brickAR = 2.4; // 預設值；載入後會更新
  brickImg.src = "brick.png";
  brickImg.onload = () => { brickReady = true; brickAR = brickImg.naturalWidth / brickImg.naturalHeight; };
  brickImg.onerror = () => { brickReady = false; /* 會改用灰磚備援繪製 */ };

  // 尺寸單位（依視窗與圖片比例）
  function brickUnit(){
    const baseW = Math.max(70, Math.min(160, W * 0.2));
    const baseH = baseW / brickAR;
    return { w: baseW, h: baseH, radius: Math.max(4, Math.min(10, baseW*0.06)) };
  }

  // 物理世界
  const engine = Engine.create();
  engine.gravity.y = 1.2;

  const render = Render.create({
    canvas, engine,
    options: { width: W*dpr, height: H*dpr, pixelRatio:dpr, wireframes:false, background:"#f5f5f5" }
  });
  Render.run(render);
  const runner = Runner.create(); Runner.run(runner, engine);

  // 邊界
  let ground, pedestal;
  function buildGround(){
    if (ground) Composite.remove(engine.world, ground);
    ground = Bodies.rectangle(W/2, H+40, W*2, 80, { isStatic:true, render:{ fillStyle:"#d6d6d6" }});
    World.add(engine.world, ground);
  }
  function buildPedestal(){
    const u = brickUnit();
    if (pedestal) Composite.remove(engine.world, pedestal);
    pedestal = Bodies.rectangle(W/2, H - (u.h/2) - 8, u.w*1.4, u.h, {
      isStatic:true, chamfer:{ radius:u.radius }, render:{ fillStyle:"#bdbdbd" }
    });
    World.add(engine.world, pedestal);
  }

  // 狀態
  let playing=false, timeLeft=15, score=0;
  let currentMover=null, moverDir=1, moverSpeed=180, lastTs=0;

  // UI
  const $score = document.getElementById('score');
  const $timer = document.getElementById('timer');
  const $center = document.getElementById('centerMsg');
  const $start = document.getElementById('startBtn');
  const $how = document.getElementById('howBtn');

  function resize(){
    W = window.innerWidth; H = window.innerHeight;
    render.canvas.width = W*dpr; render.canvas.height = H*dpr;
    render.options.width = W*dpr; render.options.height = H*dpr;
    render.canvas.style.width = W+'px'; render.canvas.style.height = H+'px';
    buildGround(); buildPedestal();
  }
  window.addEventListener('resize', resize);

  function createBrick(x,y,w,h,isStatic=false){
    return Bodies.rectangle(x,y,w,h,{
      isStatic,
      friction:0.9, frictionStatic:1.0, frictionAir:0.01, restitution:0.05,
      chamfer:{ radius:Math.min(w,h)*0.08 },
      render:{ fillStyle:"#9e9e9e", strokeStyle:"#8b8b8b", lineWidth:1.5 }
    });
  }

  function spawnMover(){
    const u = brickUnit();
    const x0 = W/2, y0 = Math.max(90, H*0.14);
    const brick = createBrick(x0,y0,u.w,u.h,true);
    World.add(engine.world, brick);
    currentMover = brick;
    moverDir = Math.random()<0.5 ? -1 : 1;
    moverSpeed = 180 + Math.min(220, score*18);
  }

  function dropMover(){
    if (!currentMover || !playing) return;
    Body.setStatic(currentMover, false);
    Body.applyForce(currentMover, currentMover.position, { x:0, y:0.002 });
    currentMover = null;
    score += 1; $score.textContent = `Score ${score}`;
    setTimeout(()=>{ if (playing) spawnMover(); }, 180);
  }

  function outOfBoundsLoseCheck(){
    const bodies = Composite.allBodies(engine.world);
    for (const b of bodies){
      if (b.isStatic || b===currentMover) continue;
      if (b.position.y > H+140){ gameOver("磚塊掉出畫面"); return true; }
    }
    return false;
  }

  function tick(ts){
    if (!playing){ lastTs=ts; return; }
    if (!lastTs) lastTs=ts;
    const dt = Math.min(0.033, (ts-lastTs)/1000); lastTs=ts;

    timeLeft = Math.max(0, timeLeft - dt);
    $timer.textContent = `Time ${timeLeft.toFixed(1)}`;
    if (timeLeft <= 3) $timer.classList.add('flash'); else $timer.classList.remove('flash');
    if (timeLeft <= 0){ gameOver("時間到"); return; }

    if (currentMover){
      const u = brickUnit();
      const margin = Math.max(28, u.w*0.55);
      const nx = currentMover.position.x + moverDir*moverSpeed*dt;
      if (nx < margin) moverDir=1; else if (nx > W - margin) moverDir=-1;
      Body.setPosition(currentMover, { x:Math.min(W-margin, Math.max(margin, nx)), y:currentMover.position.y });
    }

    outOfBoundsLoseCheck();
    requestAnimationFrame(tick);
  }

  function startGame(){
    Composite.clear(engine.world, false, true);
    buildGround(); buildPedestal();
    score=0; timeLeft=15; $score.textContent='Score 0'; $timer.textContent='Time 15.0'; $timer.classList.remove('flash');
    playing=true; $center.style.display='none';
    spawnMover(); lastTs=0; requestAnimationFrame(tick);
  }

  function gameOver(reason){
    if (!playing) return; playing=false; $timer.classList.remove('flash');
    const card = document.querySelector('#centerMsg .card');
    card.innerHTML = `
      <h1>結束囉！</h1>
      <p>原因：${reason}｜得分：<b>${score}</b></p>
      <div class="row">
        <button id="retryBtn">再玩一次</button>
        <button id="shareBtn" class="secondary">分享分數</button>
      </div>`;
    $center.style.display='flex';
    document.getElementById('retryBtn').onclick = startGame;
    document.getElementById('shareBtn').onclick = ()=>{
      const text = \`我在「疊空心磚」得到 \${score} 分！\`;
      if (navigator.share) navigator.share({ title:'疊空心磚', text });
      else navigator.clipboard.writeText(text);
      alert('已複製分數訊息！');
    };
  }

  function handleDrop(){ if (playing) dropMover(); }
  window.addEventListener('pointerdown', handleDrop, { passive:true });
  window.addEventListener('keydown', e=>{ if (e.code==='Space'){ e.preventDefault(); handleDrop(); }});

  // 綁定按鈕（保險起見也加上事件存在檢查）
  if (document.getElementById('startBtn')) document.getElementById('startBtn').onclick = startGame;
  if (document.getElementById('howBtn')) document.getElementById('howBtn').onclick = ()=>{
    const card = document.querySelector('#centerMsg .card');
    card.innerHTML = `
      <h1>操作說明</h1>
      <p>上方空心磚會左右移動；手機「點一下」或電腦「滑鼠點擊／空白鍵」放下磚塊。</p>
      <p>疊歪會失衡、傾倒或滑落，掉出畫面即結束。限時 15 秒，盡量疊高！</p>
      <div class="row"><button id="okBtn">我知道了，開始！</button></div>`;
    document.getElementById('okBtn').onclick = startGame;
  };

  // 初始
  resize();

  // 圖像渲染（PNG 成功→用圖片；失敗→用灰色方塊）
  Events.on(render, 'afterRender', ()=>{
    const ctx = render.context;
    const bodies = Composite.allBodies(engine.world);
    ctx.save(); ctx.scale(dpr, dpr);

    bodies.forEach(b=>{
      if (b === ground) return;
      const isPedestal = (b === pedestal);
      const w = b.bounds.max.x - b.bounds.min.x;
      const h = b.bounds.max.y - b.bounds.min.y;
      const { x, y } = b.position; const ang = b.angle;

      ctx.translate(x, y); ctx.rotate(ang);

      if (!isPedestal && brickReady){
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(brickImg, -w/2, -h/2, w, h);
      }else{
        const r = Math.min(w,h)*0.08;
        roundRect(ctx, -w/2, -h/2, w, h, r);
        ctx.fillStyle = isPedestal ? '#bdbdbd' : '#9e9e9e';
        ctx.fill();
        ctx.lineWidth = 1.5; ctx.strokeStyle='#8b8b8b'; ctx.stroke();
      }
      ctx.setTransform(1,0,0,1,0,0);
    });

    ctx.restore();
  });

  function roundRect(ctx,x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
})();
</script>
</body>
</html>
