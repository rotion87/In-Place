<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>疊空心磚 - 物理版</title>
<script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:#f2f2f2; }
canvas { display:block; margin:0 auto; background:#eaeaea; }
</style>
</head>
<body>
<canvas id="world"></canvas>
<script>
const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;
const canvas = document.getElementById("world");
const W = window.innerWidth;
const H = window.innerHeight;

const engine = Engine.create();
const world = engine.world;
engine.gravity.y = 1.2;

// 建立 renderer
const render = Render.create({
  canvas,
  engine,
  options: {
    width: W,
    height: H,
    background: "#f2f2f2",
    wireframes: false
  }
});
Render.run(render);
Runner.run(Runner.create(), engine);

// 地板
const ground = Bodies.rectangle(W/2, H-40, W, 80, { isStatic: true });
World.add(world, ground);

// 空心磚圖
const img = new Image();
img.src = "brick.png"; // 你的PNG
let brickReady = false;
img.onload = () => { brickReady = true; };

// 磚塊設定
const brickW = 120, brickH = 50;
let movingBrick = null;
let moveDir = 1;
let gameActive = false;
let score = 0;

// 畫面繪圖覆寫 (用圖片)
Events.on(render, "afterRender", () => {
  const ctx = render.context;
  const bodies = Matter.Composite.allBodies(world);
  ctx.save();
  bodies.forEach(b => {
    if (b === ground) return;
    ctx.translate(b.position.x, b.position.y);
    ctx.rotate(b.angle);
    if (brickReady) {
      ctx.drawImage(img, -brickW/2, -brickH/2, brickW, brickH);
    } else {
      ctx.fillStyle = "#999";
      ctx.fillRect(-brickW/2, -brickH/2, brickW, brickH);
    }
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  });
  ctx.restore();
});

// 新增一塊移動中的磚
function spawnBrick() {
  movingBrick = Bodies.rectangle(W/2, 100, brickW, brickH, {
    isStatic: true,
    render: { fillStyle: "#888" }
  });
  moveDir = 1;
  World.add(world, movingBrick);
  gameActive = true;
}

// 控制左右移動與落下
Events.on(engine, "beforeUpdate", () => {
  if (!movingBrick) return;
  const speed = 4;
  Body.setPosition(movingBrick, {
    x: movingBrick.position.x + moveDir * speed,
    y: movingBrick.position.y
  });
  if (movingBrick.position.x > W - 80) moveDir = -1;
  if (movingBrick.position.x < 80) moveDir = 1;
});

function dropBrick() {
  if (!movingBrick) return;
  Body.setStatic(movingBrick, false);
  movingBrick = null;
  score++;
  setTimeout(spawnBrick, 800);
}

window.addEventListener("click", dropBrick);
window.addEventListener("keydown", e => {
  if (e.code === "Space") dropBrick();
});

// 開始
spawnBrick();
</script>
</body>
</html>
