<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>疊空心磚 Hollow Stack (單一PNG)</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#efefef; font-family: system-ui,"Noto Sans TC",Arial,sans-serif; }
  #ui { position:fixed; inset:0 0 auto 0; display:flex; justify-content:space-between; align-items:center; padding:10px 14px; pointer-events:none; }
  .pill { background:rgba(0,0,0,.65); color:#fff; padding:6px 10px; border-radius:999px; font-weight:700; letter-spacing:.5px; box-shadow:0 2px 6px rgba(0,0,0,.2); }
  #centerMsg { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; pointer-events:none; }
  #centerMsg .card { pointer-events:auto; background:rgba(255,255,255,.92); border-radius:16px; padding:16px 18px; box-shadow:0 8px 24px rgba(0,0,0,.25); min-width:min(90vw,460px); }
  #centerMsg h1 { margin:0 0 6px 0; font-size:20px; }
  #centerMsg p { margin:6px 0 12px 0; color:#333; }
  #centerMsg .row { display:flex; gap:8px; flex-wrap:wrap; }
  button { border-radius:10px; border:none; outline:none; padding:10px 12px; font-size:16px; box-shadow:0 2px 6px rgba(0,0,0,.15); background:#111; color:#fff; cursor:pointer; }
  button.secondary { background:#e0e0e0; color:#111; }
  #canvasWrap { position:relative; width:100vw; height:100vh; }
  canvas { display:block; width:100%; height:100%; }
  .flash { animation:flash .3s linear infinite; }
  @keyframes flash { 0%{opacity:1} 50%{opacity:.25} 100%{opacity:1} }
</style>
</head>
<body>
  <div id="canvasWrap"><canvas id="game"></canvas></div>

  <div id="ui">
    <div id="score" class="pill">Score 0</div>
    <div id="timer" class="pill">Time 15.0</div>
  </div>

  <div id="centerMsg">
    <div class="card">
      <h1>疊空心磚 Hollow Stack</h1>
      <p>15 秒內，把上方左右移動的空心磚放下並堆高。疊歪會失衡、倒掉或滑出畫面就結束。<br/>手機：點一下　電腦：滑鼠點擊／空白鍵</p>
      <div class="row">
        <button id="startBtn">開始遊戲</button>
        <button id="howBtn" class="secondary">操作說明</button>
      </div>
    </div>
  </div>

  <!-- Matter.js -->
  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
  (function(){
    const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

    const canvas = document.getElementById('game');
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    let W = window.innerWidth, H = window.innerHeight;

    // —— 固定使用單一 PNG —— //
    const brickImg = new Image();
    let brickReady = false, brickAR = 2.4; // 預設寬高比，圖片載入後會自動覆蓋
    brickImg.src = "brick.png";  // 把你的兩孔磚圖命名為 brick.png 放同資料夾
    brickImg.onload = () => { brickReady = true; brickAR = brickImg.naturalWidth / brickImg.naturalHeight; };

    // 依視窗決定基準尺寸；高度由圖片寬高比決定
    function brickUnit() {
      const baseW = Math.max(70, Math.min(160, W * 0.2)); // 寬度
      const baseH = baseW / brickAR;                      // 高度 = 寬 / 比例
      return { w: baseW, h: baseH, radius: Math.max(4, Math.min(10, baseW * 0.06)) };
    }

    // 物理世界
    const engine = Engine.create();
    engine.gravity.y = 1.2;

    const render = Render.create({
      canvas, engine,
      options:{ width: W*dpr, height: H*dpr, pixelRatio:dpr, wireframes:false, background:"#f5f5f5" }
    });
    Render.run(render);
    const runner = Runner.create(); Runner.run(runner, engine);

    // 邊界
    let ground, pedestal;
    function buildGround(){
      if (ground) Composite.remove(engine.world, ground);
      ground = Bodies.rectangle(W/2, H+40, W*2, 80, { isStatic:true, render:{ fillStyle:"#d6d6d6" }});
      World.add(engine.world, ground);
    }
    function buildPedestal(){
      const u = brickUnit();
      if (pedestal) Composite.remove(engine.world, pedestal);
      pedestal = Bodies.rectangle(W/2, H - (u.h/2) - 8, u.w*1.4, u.h, {
        isStatic:true, chamfer:{ radius:u.radius }, render:{ fillStyle:"#bdbdbd" }
      });
      World.add(engine.world, pedestal);
    }

    // 狀態
    let playing=false, timeLeft=15.0, score=0;
    let currentMover=null, moverDir=1, moverSpeed=180, lastTs=0;

    // UI
    const $score = document.getElementById('score');
    const $timer = document.getElementById('timer');
    const $center = document.getElementById('centerMsg');
    const $start = document.getElementById('startBtn');
    const $how = document.getElementById('howBtn');

    function resize(){
      W = window.innerWidth; H = window.innerHeight;
      render.canvas.width = W*dpr; render.canvas.height = H*dpr;
      render.options.width = W*dpr; render.options.height = H*dpr;
      render.canvas.style.width = W+"px"; render.canvas.style.height = H+"px";
      buildGround(); buildPedestal();
    }
    window.addEventListener('resize', resize);

    function createBrick(x,y,w,h,isStatic=false){
      return Bodies.rectangle(x,y,w,h,{
        isStatic,
        friction:0.9, frictionStatic:1.0, frictionAir:0.01, restitution:0.05,
        chamfer:{ radius:Math.min(w,h)*0.08 },
        render:{ fillStyle:"#9e9e9e", strokeStyle:"#8b8b8b", lineWidth:1.5 }
      });
    }

    function spawnMover(){
      const u = brickUnit();
      const x0 = W/2, y0 = Math.max(90, H*0.14);
      const brick = createBrick(x0,y0,u.w,u.h,true);
      World.add(engine.world, brick);
      currentMover = brick;
      moverDir = Math.random()<0.5 ? -1 : 1;
      moverSpeed = 180 + Math.min(220, score*18);
    }

    function dropMover(){
      if (!currentMover || !playing) return;
      Body.setStatic(currentMover, false);
      Body.applyForce(currentMover, currentMover.position, { x:0, y:0.002 });
      currentMover = null;
      score += 1; $score.textContent = `Score ${score}`;
      setTimeout(()=>{ if (playing) spawnMover(); }, 180);
    }

    function outOfBoundsLoseCheck(){
      const bodies = Composite.allBodies(engine.world);
      for (const b of bodies){
        if (b.isStatic || b===currentMover) continue;
        if (b.position.y > H+140){ gameOver("磚塊掉出畫面"); return true; }
      }
      return false;
    }

    function tick(ts){
      if (!playing){ lastTs=ts; return; }
      if (!lastTs) lastTs = ts;
      const dt = Math.min(0.033, (ts - lastTs)/1000);
      lastTs = ts;

      timeLeft = Math.max(0, timeLeft - dt);
      $timer.textContent = `Time ${timeLeft.toFixed(1)}`;
      if (timeLeft <= 3) $timer.classList.add('flash'); else $timer.classList.remove('flash');
      if (timeLeft <= 0){ gameOver("時間到"); return; }

      if (currentMover){
        const u = brickUnit();
        const margin = Math.max(28, u.w*0.55);
        const nx = currentMover.position.x + moverDir*moverSpeed*dt;
        if (nx < margin) moverDir=1; else if (nx > W - margin) moverDir=-1;
        Body.setPosition(currentMover, { x:Math.min(W-margin, Math.max(margin, nx)), y:currentMover.position.y });
      }

      outOfBoundsLoseCheck();
      requestAnimationFrame(tick);
    }

    function startGame(){
      Composite.clear(engine.world, false, true);
      buildGround(); buildPedestal();
      score=0; timeLeft=15; $score.textContent="Score 0"; $timer.textContent="Time 15.0"; $timer.classList.remove('flash');
      playing=true; $center.style.display="none";
      spawnMover(); lastTs=0; requestAnimationFrame(tick);
    }

    function gameOver(reason){
      if (!playing) return; playing=false; $timer.classList.remove('flash');
      const card = document.querySelector('#centerMsg .card');
      card.innerHTML = `
        <h1>結束囉！</h1>
        <p>原因：${reason}｜得分：<b>${score}</b></p>
        <div class="row">
          <button id="retryBtn">再玩一次</button>
          <button id="shareBtn" class="secondary">分享分數</button>
        </div>`;
      $center.style.display="flex";
      document.getElementById('retryBtn').onclick = startGame;
      document.getElementById('shareBtn').onclick = () => {
        const text = \`我在「疊空心磚」得到 \${score} 分！\`;
        if (navigator.share) navigator.share({ title:"疊空心磚", text });
        else navigator.clipboard.writeText(text);
        alert("已複製分數訊息！");
      };
    }

    function handleDrop(){ if (playing) dropMover(); }
    window.addEventListener('pointerdown', handleDrop, { passive:true });
    window.addEventListener('keydown', (e)=>{ if (e.code==="Space"){ e.preventDefault(); handleDrop(); } });

    $start.onclick = startGame;
    $how.onclick = ()=>{
      const card = document.querySelector('#centerMsg .card');
      card.innerHTML = `
        <h1>操作說明</h1>
        <p>上方空心磚會左右移動；手機「點一下」或電腦「滑鼠點擊／空白鍵」放下磚塊。</p>
        <p>疊歪會失衡、傾倒或滑落，掉出畫面即結束。限時 15 秒，盡量疊高！</p>
        <div class="row"><button id="okBtn">我知道了，開始！</button></div>`;
      document.getElementById('okBtn').onclick = startGame;
    };

    resize();

    // —— 使用 PNG 貼圖繪製 —— //
    Events.on(render, 'afterRender', () => {
      const ctx = render.context;
      const bodies = Composite.allBodies(engine.world);
      ctx.save();
      ctx.scale(dpr, dpr);

      bodies.forEach(b=>{
        if (b === ground) return;           // 地面不畫
        const isPedestal = (b === pedestal);

        const w = b.bounds.max.x - b.bounds.min.x;
        const h = b.bounds.max.y - b.bounds.min.y;
        const { x, y } = b.position;
        const ang = b.angle;

        ctx.translate(x, y);
        ctx.rotate(ang);

        if (!isPedestal && brickReady){
          // 以 PNG 覆蓋；實體尺寸 = 剛體寬高，避免變形（高由 brickAR 控制）
          ctx.imageSmoothingEnabled = true;
          ctx.drawImage(brickImg, -w/2, -h/2, w, h);
        } else {
          // 備援與基座
          const r = Math.min(w,h)*0.08;
          roundRect(ctx, -w/2, -h/2, w, h, r);
          ctx.fillStyle = isPedestal ? "#bdbdbd" : "#9e9e9e";
          ctx.fill();
          ctx.lineWidth = 1.5; ctx.strokeStyle = "#8b8b8b"; ctx.stroke();
        }

        ctx.setTransform(1,0,0,1,0,0);
      });

      ctx.restore();
    });

    function roundRect(ctx,x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }
  })();
  </script>
</body>
</html>
