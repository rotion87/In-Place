<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>æ‰¾è‰²æŒ‘æˆ° Color Match</title>
<style>
  :root { --bg:#0f1115; --panel:#181b22; --text:#e7eef7; --muted:#9aa3af; --accent:#79c0ff; }
  * { box-sizing: border-box; }
  body {
    margin: 0; background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, "Noto Sans TC", "Segoe UI", Roboto, Arial;
    display: grid; min-height: 100svh; grid-template-rows: auto 1fr auto;
  }
  header, footer { padding: 12px 16px; background: #0b0d11; border-bottom: 1px solid #20242c; }
  footer { border-top: 1px solid #20242c; border-bottom: none; color: var(--muted); font-size: 12px; }
  main { padding: 16px; display: grid; gap: 12px; }
  .wrap { display: grid; gap: 12px; }
  .row { display: grid; gap: 12px; }
  @media (min-width: 900px) {
    .row { grid-template-columns: 1.2fr 1fr; align-items: start; }
  }

  /* camera panel */
  .camera {
    background: var(--panel); border: 1px solid #232832; border-radius: 12px; overflow: hidden;
    position: relative; aspect-ratio: 3/4; display: grid; place-items: center;
  }
  video { width: 100%; height: 100%; object-fit: cover; display: block; }
  .aim {
    position: absolute; inset: 0; pointer-events: none;
    display: grid; place-items: center;
  }
  .aim::before {
    content: ""; width: 44%; aspect-ratio: 1/1; border-radius: 12px;
    outline: 2px dashed rgba(255,255,255,.35); outline-offset: -8px;
    box-shadow: inset 0 0 0 9999px rgba(0,0,0,.12);
  }

  .controls { display:flex; gap:8px; flex-wrap: wrap; }
  button {
    appearance: none; border: 1px solid #2a3342; background:#0f131a; color: var(--text);
    padding: 10px 14px; border-radius: 10px; font-weight: 600; cursor: pointer;
  }
  button.primary { background: linear-gradient(180deg, #1a8cff, #0066ff); border-color:#175bba; }
  button:disabled { opacity: .6; cursor: not-allowed; }

  /* target + result */
  .card {
    background: var(--panel); border: 1px solid #232832; border-radius: 12px; padding: 12px;
  }
  .target {
    display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
    align-items: center;
  }
  .swatch {
    background: #000; border-radius: 10px; height: 72px; border: 1px solid #2a3342;
  }
  .meta { font-size: 12px; color: var(--muted); }
  .big {
    font-size: 40px; font-weight: 800; letter-spacing: .5px;
    background: linear-gradient(90deg, #9bd7ff, #b9ffea); -webkit-background-clip: text; background-clip: text; color: transparent;
  }
  .scoreline { display:flex; gap:12px; align-items: baseline; flex-wrap: wrap; }
  .tag { font-size:12px; padding:4px 8px; border-radius: 999px; border:1px solid #2a3342; background:#0f131a; color:#cfe6ff; }

  .statusbar {
    display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content: space-between;
    background:#0c0f14; border:1px solid #232832; padding:8px 12px; border-radius:10px;
  }
  .timer { font-variant-numeric: tabular-nums; font-weight:700; }
  .round { color: var(--muted); }
  .hint { color:#b7c3d7; font-size:13px; }
  .warn { color:#ffd166; }

  canvas { display:none; }
</style>
</head>
<body>
  <header>
    <strong>æ‰¾è‰²æŒ‘æˆ° Â· Color Match</strong>
  </header>

  <main>
    <div class="wrap">
      <div class="statusbar">
        <div class="round">å›åˆï¼š<span id="roundNow">1</span>/<span id="roundMax">3</span></div>
        <div class="timer">å€’æ•¸ï¼š<span id="timeLeft">15.0</span>s</div>
        <div class="hint">æŠŠé¡é ­å°æº–ç›®æ¨™è‰²é™„è¿‘çš„ç‰©ä»¶ï¼Œæ¡†ä½å¾ŒæŒ‰ã€Œæ‹ç…§ã€</div>
      </div>

      <div class="row">
        <!-- Camera -->
        <div class="card">
          <div class="camera">
            <video id="video" autoplay playsinline muted></video>
            <div class="aim"></div>
          </div>
          <div class="controls" style="margin-top:10px">
            <button id="btnStart" class="primary">é–‹å§‹é¡é ­</button>
            <button id="btnNew" title="æ›ä¸€å€‹ç›®æ¨™è‰²">æ›é¡Œ</button>
            <button id="btnCapture">æ‹ç…§åˆ¤å®š</button>
            <button id="btnNext">ä¸‹ä¸€å›åˆ</button>
          </div>
          <div class="meta" style="margin-top:8px">
            éš±ç§èªªæ˜ï¼šå½±åƒåƒ…ç”¨æ–¼æœ¬æ©Ÿæ¯”å°ï¼Œä¸æœƒä¸Šå‚³ã€‚
          </div>
        </div>

        <!-- Target & Result -->
        <div class="card">
          <div style="display:grid; gap:10px;">
            <div>
              <div class="meta">ç›®æ¨™è‰²</div>
              <div class="target">
                <div id="targetSwatch" class="swatch"></div>
                <div>
                  <div id="targetHex" style="font-weight:700;"></div>
                  <div id="targetHsl" class="meta"></div>
                </div>
              </div>
            </div>

            <div>
              <div class="meta">ä½ çš„æ‹æ”</div>
              <div class="target">
                <div id="shotSwatch" class="swatch" style="background:#111;"></div>
                <div>
                  <div id="shotHex" style="font-weight:700;">â€”</div>
                  <div id="shotHsl" class="meta">â€”</div>
                </div>
              </div>
            </div>

            <div class="scoreline">
              <div class="big" id="score">0</div>
              <span class="tag" id="deltaE">Î”E â€”</span>
              <span class="tag" id="judgement">å°šæœªåˆ¤å®š</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- hidden canvas for capture/analysis -->
    <canvas id="canvas" width="720" height="960"></canvas>
  </main>

  <footer>
    å°æŠ€å·§ï¼šå…‰æºå½±éŸ¿å¾ˆå¤§ï¼Œæ‰¾ã€Œé£½å’Œä½†ä¸åˆºçœ¼ã€çš„å€åŸŸæœƒæ›´å®¹æ˜“é«˜åˆ†ï¼›å¤ªæš—/å¤ªäº®éƒ½æœƒå¤±çœŸã€‚
  </footer>

<script>
(function(){
  /*** DOM refs ***/
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  const btnStart = document.getElementById('btnStart');
  const btnNew = document.getElementById('btnNew');
  const btnCapture = document.getElementById('btnCapture');
  const btnNext = document.getElementById('btnNext');

  const targetSwatch = document.getElementById('targetSwatch');
  const targetHex = document.getElementById('targetHex');
  const targetHsl = document.getElementById('targetHsl');

  const shotSwatch = document.getElementById('shotSwatch');
  const shotHex = document.getElementById('shotHex');
  const shotHsl = document.getElementById('shotHsl');

  const scoreEl = document.getElementById('score');
  const deltaEEl = document.getElementById('deltaE');
  const judgeEl = document.getElementById('judgement');

  const roundNowEl = document.getElementById('roundNow');
  const roundMaxEl = document.getElementById('roundMax');
  const timeLeftEl = document.getElementById('timeLeft');

  /*** Game state ***/
  const ROUND_MAX = 3;
  const TIME_PER_ROUND = 15.0; // ç§’
  let roundNow = 1;
  let timer = null;
  let timeLeft = TIME_PER_ROUND;
  let stream = null;

  let target = null; // {r,g,b}
  let lastShot = null; // {r,g,b}

  /*** Utils: color conversions ***/
  function clamp01(x){ return Math.min(1, Math.max(0, x)); }
  function rgbToHex({r,g,b}) {
    return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('').toUpperCase();
  }
  function rgbToHsl({r,g,b}) {
    // r,g,b: 0-255
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0, s=0, l=(max+min)/2;
    if(max!==min){
      const d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d + (g<b?6:0); break;
        case g: h=(b-r)/d + 2; break;
        case b: h=(r-g)/d + 4; break;
      }
      h/=6;
    }
    return { h: Math.round(h*360), s: Math.round(s*100), l: Math.round(l*100) };
  }

  // sRGB -> XYZ -> Lab (D65)
  function srgbToXyz(v){ // v in [0,1]
    return (v<=0.04045)? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
  }
  function rgbToLab({r,g,b}) {
    let R=srgbToXyz(r/255), G=srgbToXyz(g/255), B=srgbToXyz(b/255);
    // sRGB D65
    let X = R*0.4124564 + G*0.3575761 + B*0.1804375;
    let Y = R*0.2126729 + G*0.7151522 + B*0.0721750;
    let Z = R*0.0193339 + G*0.1191920 + B*0.9503041;
    // reference white D65
    const Xn=0.95047, Yn=1.00000, Zn=1.08883;
    function f(t){ return t>0.008856 ? Math.cbrt(t) : (7.787*t + 16/116); }
    let fx=f(X/Xn), fy=f(Y/Yn), fz=f(Z/Zn);
    return { L: (116*fy - 16), a: 500*(fx - fy), b: 200*(fy - fz) };
  }

  // CIEDE2000
  // reference: Sharma et al. 2005
  function ciede2000(lab1, lab2) {
    const {L:L1,a:a1,b:b1} = lab1;
    const {L:L2,a:a2,b:b2} = lab2;
    const kL=1,kC=1,kH=1;

    const C1 = Math.hypot(a1,b1);
    const C2 = Math.hypot(a2,b2);
    const Cbar = (C1+C2)/2;

    const G = 0.5 * (1 - Math.sqrt(Math.pow(Cbar,7) / (Math.pow(Cbar,7) + Math.pow(25,7))));
    const a1p = (1+G)*a1;
    const a2p = (1+G)*a2;
    const C1p = Math.hypot(a1p,b1);
    const C2p = Math.hypot(a2p,b2);

    const h1p = (Math.atan2(b1,a1p)*180/Math.PI + 360) % 360;
    const h2p = (Math.atan2(b2,a2p)*180/Math.PI + 360) % 360;

    const dLp = L2 - L1;
    const dCp = C2p - C1p;

    let dhp;
    if (C1p*C2p === 0) dhp = 0;
    else {
      const diff = h2p - h1p;
      if (Math.abs(diff) <= 180) dhp = diff;
      else dhp = diff > 180 ? diff - 360 : diff + 360;
    }
    const dHp = 2 * Math.sqrt(C1p*C2p) * Math.sin((dhp/2) * Math.PI/180);

    const Lbar = (L1+L2)/2;
    const Cpbar = (C1p+C2p)/2;

    let hpbar;
    if (C1p*C2p === 0) hpbar = h1p + h2p;
    else {
      const diff = Math.abs(h1p - h2p);
      if (diff <= 180) hpbar = (h1p + h2p)/2;
      else hpbar = (h1p + h2p + 360)/2 - (h1p + h2p >= 360 ? 360 : 0);
    }

    const T = 1 - 0.17*Math.cos(( (hpbar-30) * Math.PI/180))
                + 0.24*Math.cos(( (2*hpbar) * Math.PI/180))
                + 0.32*Math.cos(( (3*hpbar+6) * Math.PI/180))
                - 0.20*Math.cos(( (4*hpbar-63) * Math.PI/180));

    const Sl = 1 + (0.015*Math.pow(Lbar-50,2))/Math.sqrt(20 + Math.pow(Lbar-50,2));
    const Sc = 1 + 0.045*Cpbar;
    const Sh = 1 + 0.015*Cpbar*T;

    const deltaTheta = 30 * Math.exp(- Math.pow((hpbar-275)/25, 2));
    const Rc = 2 * Math.sqrt( Math.pow(Cpbar,7) / (Math.pow(Cpbar,7) + Math.pow(25,7)) );
    const Rt = -Rc * Math.sin(2*deltaTheta * Math.PI/180);

    const dE = Math.sqrt(
      Math.pow(dLp/(kL*Sl),2) +
      Math.pow(dCp/(kC*Sc),2) +
      Math.pow(dHp/(kH*Sh),2) +
      Rt * (dCp/(kC*Sc)) * (dHp/(kH*Sh))
    );
    return dE;
  }

  /*** Color helpers ***/
  function hslToRgb(h, s, l) {
    // h in [0,360], s,l in [0,100]
    s/=100; l/=100;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = h/60;
    const x = c * (1 - Math.abs((hp % 2) - 1));
    let r1=0,g1=0,b1=0;
    if (0<=hp && hp<1){ r1=c; g1=x; b1=0; }
    else if (1<=hp && hp<2){ r1=x; g1=c; b1=0; }
    else if (2<=hp && hp<3){ r1=0; g1=c; b1=x; }
    else if (3<=hp && hp<4){ r1=0; g1=x; b1=c; }
    else if (4<=hp && hp<5){ r1=x; g1=0; b1=c; }
    else if (5<=hp && hp<=6){ r1=c; g1=0; b1=x; }
    const m = l - c/2;
    return {
      r: Math.round((r1+m)*255),
      g: Math.round((g1+m)*255),
      b: Math.round((b1+m)*255),
    };
  }

  function randomTargetColor() {
    // é¿å…å¤ªé»‘/å¤ªç™½/å¤ªè¢å…‰ï¼šé™åˆ¶å€é–“
    const h = Math.floor(Math.random()*360);
    const s = Math.floor(55 + Math.random()*35); // 55â€“90
    const l = Math.floor(40 + Math.random()*25); // 40â€“65
    const rgb = hslToRgb(h,s,l);
    return { rgb, hsl:{h,s,l} };
  }

  /*** Sampling captured frame ***/
  function captureCenterAverage(sampleBoxRatio=0.44) {
    // æŠŠ video ç•«åˆ° canvasï¼ˆç¶­æŒç›´ç«‹æ¯”ä¾‹ï¼‰
    // æ³¨æ„ï¼šæŸäº›è£ç½® videoWidth/Height éœ€è¦ç­‰å¾… loadedmetadata
    const vw = video.videoWidth || 720;
    const vh = video.videoHeight || 960;
    canvas.width = vw;
    canvas.height = vh;
    ctx.drawImage(video, 0, 0, vw, vh);

    // å–ä¸­å¤®æ–¹æ¡†å¹³å‡è‰²ï¼ˆå°æ‡‰ç•«é¢ç„æº–æ¡†ï¼‰
    const boxW = Math.floor(vw * sampleBoxRatio);
    const boxH = Math.floor(vh * sampleBoxRatio);
    const x0 = Math.floor((vw - boxW)/2);
    const y0 = Math.floor((vh - boxH)/2);

    const img = ctx.getImageData(x0, y0, boxW, boxH).data;
    let r=0,g=0,b=0,count=0;

    // å¿½ç•¥æ¥µç«¯äº®/æš—å€¼ä»¥æŠ—é›œè¨Š
    for (let i=0; i<img.length; i+=4) {
      const R=img[i], G=img[i+1], B=img[i+2];
      const Luma = 0.2126*R + 0.7152*G + 0.0722*B;
      if (Luma < 10 || Luma > 245) continue;
      r+=R; g+=G; b+=B; count++;
    }
    if (count===0) { return {r:0,g:0,b:0}; }
    return { r: Math.round(r/count), g: Math.round(g/count), b: Math.round(b/count) };
  }

  /*** Scoring ***/
  function scoreFromDeltaE(dE) {
    // 0 åˆ†ï¼šå·®å¾ˆå¤šï¼›100 åˆ†ï¼šå¹¾ä¹ç›¸åŒ
    // ä½¿ç”¨é«˜æ–¯è¡°æ¸›ï¼Œ15 ç‚ºç´„ç•¥å¯è¾¨é–¾å€¼å°ºåº¦
    const s = Math.exp(- Math.pow(dE/15, 2));
    return Math.round(100 * s);
  }
  function judgeFromDeltaE(dE) {
    if (dE < 2) return "å¹¾ä¹ä¸€æ¨£ ğŸ˜²";
    if (dE < 5) return "éå¸¸æ¥è¿‘ ğŸ”¥";
    if (dE < 10) return "ä¸éŒ¯äº† ğŸ‘";
    if (dE < 20) return "é‚„å¯ä»¥ ğŸ‘€";
    return "å†è©¦è©¦çœ‹ï½ ğŸ’ª";
  }

  /*** UI helpers ***/
  function setTarget({rgb,hsl}) {
    target = rgb;
    targetSwatch.style.background = rgbToHex(rgb);
    targetHex.textContent = rgbToHex(rgb);
    targetHsl.textContent = `HSL(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
  }
  function setShot(rgb) {
    lastShot = rgb;
    const hex = rgbToHex(rgb);
    shotSwatch.style.background = hex;
    shotHex.textContent = hex;
    const hsl = rgbToHsl(rgb);
    shotHsl.textContent = `HSL(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
  }
  function setScore(dE) {
    const sc = scoreFromDeltaE(dE);
    scoreEl.textContent = sc.toString();
    deltaEEl.textContent = `Î”E ${dE.toFixed(2)}`;
    judgeEl.textContent = judgeFromDeltaE(dE);
  }
  function resetShotAndScore() {
    setShot({r:17,g:17,b:17});
    scoreEl.textContent = "0";
    deltaEEl.textContent = "Î”E â€”";
    judgeEl.textContent = "å°šæœªåˆ¤å®š";
  }

  /*** Timer ***/
  function startTimer() {
    stopTimer();
    timeLeft = TIME_PER_ROUND;
    timeLeftEl.textContent = timeLeft.toFixed(1);
    const startedAt = performance.now();
    timer = requestAnimationFrame(function tick(t){
      const dt = (t - startedAt)/1000;
      const remain = Math.max(0, TIME_PER_ROUND - dt);
      timeLeftEl.textContent = remain.toFixed(1);
      if (remain <= 0) {
        stopTimer();
        btnCapture.disabled = true;
        judgeEl.textContent = "æ™‚é–“åˆ° â±ï¸";
        return;
      }
      timer = requestAnimationFrame(tick);
    });
  }
  function stopTimer() {
    if (timer) cancelAnimationFrame(timer);
    timer = null;
  }

  /*** Camera ***/
  async function startCamera() {
    try {
      if (stream) {
        // already started
        return;
      }
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1280 },
          height: { ideal: 1920 }
        },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      alert("ç„¡æ³•é–‹å•Ÿé¡é ­ï¼Œè«‹ç¢ºèªæ¬Šé™èˆ‡ HTTPSã€‚");
      console.error(e);
    }
  }

  /*** Round flow ***/
  function newRound(isNext=false) {
    if (isNext) {
      roundNow = Math.min(ROUND_MAX, roundNow+1);
      roundNowEl.textContent = String(roundNow);
    }
    if (roundNow > ROUND_MAX) return;

    setTarget(randomTargetColor());
    resetShotAndScore();

    btnCapture.disabled = false;
    startTimer();
  }

  function endGameIfNeeded() {
    if (roundNow >= ROUND_MAX) {
      stopTimer();
      btnCapture.disabled = true;
      judgeEl.textContent += " | æŒ‘æˆ°çµæŸ ğŸ‰";
    }
  }

  /*** Events ***/
  btnStart.addEventListener('click', async ()=>{
    await startCamera();
    // ç­‰åˆ°èƒ½æ‹¿åˆ°å°ºå¯¸å†å‡ºç¬¬ä¸€é¡Œ
    if (video.readyState >= 2) {
      newRound(false);
      btnStart.disabled = true;
    } else {
      video.addEventListener('loadedmetadata', ()=>{
        newRound(false);
        btnStart.disabled = true;
      }, { once:true });
    }
  });

  btnNew.addEventListener('click', ()=>{
    setTarget(randomTargetColor());
    resetShotAndScore();
    // ä¿æŒåŸå€’æ•¸
  });

  btnCapture.addEventListener('click', ()=>{
    if (!target) return;
    const shot = captureCenterAverage(0.44);
    setShot(shot);
    // compute Î”E
    const dE = ciede2000( rgbToLab(target), rgbToLab(shot) );
    setScore(dE);
  });

  btnNext.addEventListener('click', ()=>{
    newRound(true);
    endGameIfNeeded();
  });

  // åˆå§‹åŒ–
  roundMaxEl.textContent = String(ROUND_MAX);
  roundNowEl.textContent = String(roundNow);
})();
</script>
</body>
</html>